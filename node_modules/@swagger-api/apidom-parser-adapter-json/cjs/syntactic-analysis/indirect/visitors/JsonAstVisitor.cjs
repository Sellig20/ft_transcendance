"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
exports.__esModule = true;
exports.keyMap = exports.isNode = exports.getNodeType = exports.default = void 0;
var _stampit = _interopRequireDefault(require("stampit"));
var _apidomAst = require("@swagger-api/apidom-ast");
var _apidomCore = require("@swagger-api/apidom-core");
const keyMap = exports.keyMap = {
  // @ts-ignore
  [_apidomAst.ParseResult.type]: ['children'],
  // @ts-ignore
  [_apidomAst.JsonDocument.type]: ['children'],
  // @ts-ignore
  [_apidomAst.JsonObject.type]: ['children'],
  // @ts-ignore
  [_apidomAst.JsonProperty.type]: ['children'],
  // @ts-ignore
  [_apidomAst.JsonArray.type]: ['children'],
  // @ts-ignore
  [_apidomAst.Error.type]: ['children'],
  ..._apidomCore.keyMap
};
const getNodeType = node => {
  if ((0, _apidomCore.isParseResultElement)(node)) {
    return 'ParseResultElement';
  }
  if ((0, _apidomCore.isElement)(node)) {
    return (0, _apidomCore.getNodeType)(node);
  }
  return (0, _apidomAst.getNodeType)(node);
};
exports.getNodeType = getNodeType;
const isNode = element => (0, _apidomCore.isElement)(element) || (0, _apidomAst.isNode)(element);

/* eslint-disable no-underscore-dangle */
exports.isNode = isNode;
const JsonAstVisitor = (0, _stampit.default)({
  props: {
    sourceMap: false,
    annotations: []
  },
  init() {
    /**
     * Private API.
     */

    this.annotation = [];
    const maybeAddSourceMap = (node, element) => {
      if (!this.sourceMap) {
        return;
      }
      const sourceMap = new _apidomCore.SourceMapElement();
      // @ts-ignore
      sourceMap.position = node.position;
      // @ts-ignore
      sourceMap.astNode = node;
      element.meta.set('sourceMap', sourceMap);
    };

    /**
     * Public API.
     */

    this.document = function document(node) {
      const element = new _apidomCore.ParseResultElement();
      // @ts-ignore
      element._content = node.children;
      return element;
    };
    this.ParseResultElement = {
      leave(element) {
        // mark first-non Annotation element as result
        // @ts-ignore
        const elements = element.findElements(_apidomCore.isPrimitiveElement);
        if (elements.length > 0) {
          const resultElement = elements[0];
          resultElement.classes.push('result');
        }

        // provide annotations
        this.annotations.forEach(annotationElement => {
          element.push(annotationElement);
        });
        this.annotations = [];
      }
    };
    this.object = function object(node) {
      const element = new _apidomCore.ObjectElement();
      // @ts-ignore
      element._content = node.children;
      maybeAddSourceMap(node, element);
      return element;
    };
    this.property = function property(node) {
      const element = new _apidomCore.MemberElement();

      // @ts-ignore
      element.content.key = node.key;
      // @ts-ignore
      element.content.value = node.value;
      maybeAddSourceMap(node, element);

      /**
       * Process possible errors here that may be present in pair node children as we're using direct field access.
       * There are usually 3 children here found: "key", ":", "value".
       */
      if (node.children.length > 3) {
        node.children.filter(child => child.type === 'error').forEach(errorNode => {
          this.error(errorNode, node, [], [node]);
        });
      }
      return element;
    };
    this.key = function key(node) {
      const element = new _apidomCore.StringElement(node.value);
      maybeAddSourceMap(node, element);
      return element;
    };
    this.array = function array(node) {
      const element = new _apidomCore.ArrayElement();
      // @ts-ignore
      element._content = node.children;
      maybeAddSourceMap(node, element);
      return element;
    };
    this.string = function string(node) {
      const element = new _apidomCore.StringElement(node.value);
      maybeAddSourceMap(node, element);
      return element;
    };
    this.number = function number(node) {
      const element = new _apidomCore.NumberElement(Number(node.value));
      maybeAddSourceMap(node, element);
      return element;
    };

    // eslint-disable-next-line @typescript-eslint/naming-convention
    this.null = function _null(node) {
      const element = new _apidomCore.NullElement();
      maybeAddSourceMap(node, element);
      return element;
    };

    // eslint-disable-next-line @typescript-eslint/naming-convention
    this.true = function _true(node) {
      const element = new _apidomCore.BooleanElement(true);
      maybeAddSourceMap(node, element);
      return element;
    };

    // eslint-disable-next-line @typescript-eslint/naming-convention
    this.false = function _false(node) {
      const element = new _apidomCore.BooleanElement(false);
      maybeAddSourceMap(node, element);
      return element;
    };
    this.literal = function literal(node) {
      if (node.isMissing) {
        const message = `(Missing ${node.value})`;
        const element = new _apidomCore.AnnotationElement(message);
        element.classes.push('warning');
        maybeAddSourceMap(node, element);
        this.annotations.push(element);
      }
      return null;
    };
    this.error = function error(node, key, parent, path) {
      const message = node.isUnexpected ? `(Unexpected ${node.value})` : `(Error ${node.value})`;
      const element = new _apidomCore.AnnotationElement(message);
      element.classes.push('error');
      maybeAddSourceMap(node, element);
      if (path.length === 0) {
        // no document to visit, only error is present in CST
        const parseResultElement = new _apidomCore.ParseResultElement();
        parseResultElement.push(element);
        return parseResultElement;
      }
      this.annotations.push(element);
      return null;
    };
  }
});
var _default = exports.default = JsonAstVisitor;