"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
exports.__esModule = true;
exports.keyMap = exports.isNode = exports.default = void 0;
var _stampit = _interopRequireDefault(require("stampit"));
var _apidomAst = require("@swagger-api/apidom-ast");
var _TreeCursorSyntaxNode = _interopRequireDefault(require("../../TreeCursorSyntaxNode.cjs"));
const keyMap = exports.keyMap = {
  stream: ['children'],
  document: ['children'],
  mapping: ['children'],
  keyValuePair: ['children'],
  sequence: ['children'],
  error: ['children']
};

// @ts-ignore
const isNode = node => Array.isArray(node) || (0, _apidomAst.isNode)(node);

/* eslint-disable no-param-reassign */
exports.isNode = isNode;
const CstVisitor = (0, _stampit.default)({
  props: {
    schema: null
  },
  init() {
    /**
     * Private API.
     */

    const toPosition = node => {
      const start = (0, _apidomAst.Point)({
        row: node.startPosition.row,
        column: node.startPosition.column,
        char: node.startIndex
      });
      const end = (0, _apidomAst.Point)({
        row: node.endPosition.row,
        column: node.endPosition.column,
        char: node.endIndex
      });
      return (0, _apidomAst.Position)({
        start,
        end
      });
    };
    const kindNodeToYamlTag = node => {
      const {
        tag: tagNode
      } = node;
      const explicitName = (tagNode == null ? void 0 : tagNode.text) || (node.type === 'plain_scalar' ? '?' : '!');
      const kind = node.type.endsWith('mapping') ? _apidomAst.YamlNodeKind.Mapping : node.type.endsWith('sequence') ? _apidomAst.YamlNodeKind.Sequence : _apidomAst.YamlNodeKind.Scalar;
      const position = tagNode ? toPosition(tagNode) : null;
      return (0, _apidomAst.YamlTag)({
        explicitName,
        kind,
        position
      });
    };
    const kindNodeToYamlAnchor = node => {
      const {
        anchor: anchorNode
      } = node;
      if (typeof anchorNode === 'undefined') return null;
      return (0, _apidomAst.YamlAnchor)({
        name: anchorNode.text,
        position: toPosition(anchorNode)
      });
    };
    const isKind = ending => node => typeof (node == null ? void 0 : node.type) === 'string' && node.type.endsWith(ending);
    const isScalar = isKind('scalar');
    const isMapping = isKind('mapping');
    const isSequence = isKind('sequence');
    const hasKeyValuePairEmptyKey = node => {
      if (node.type !== 'block_mapping_pair' && node.type !== 'flow_pair') {
        return false;
      }
      // keyNode was not explicitly provided; tag and anchor are missing too
      return typeof node.keyNode === 'undefined';
    };
    const hasKeyValuePairEmptyValue = node => {
      if (node.type !== 'block_mapping_pair' && node.type !== 'flow_pair') {
        return false;
      }
      // valueNode was not explicitly provided; tag and anchor are missing too
      return typeof node.valueNode === 'undefined';
    };
    const createKeyValuePairEmptyKey = node => {
      const emptyPoint = (0, _apidomAst.Point)({
        row: node.startPosition.row,
        column: node.startPosition.column,
        char: node.startIndex
      });
      const {
        keyNode
      } = node;
      const children = (keyNode == null ? void 0 : keyNode.children) || [];
      const tagNode = children.find(isKind('tag'));
      const anchorNode = children.find(isKind('anchor'));
      const tag = typeof tagNode !== 'undefined' ? (0, _apidomAst.YamlTag)({
        explicitName: tagNode.text,
        kind: _apidomAst.YamlNodeKind.Scalar,
        position: toPosition(tagNode)
      }) : (0, _apidomAst.YamlTag)({
        explicitName: '?',
        kind: _apidomAst.YamlNodeKind.Scalar
      });
      const anchor = typeof anchorNode !== 'undefined' ? (0, _apidomAst.YamlAnchor)({
        name: anchorNode.text,
        position: toPosition(anchorNode)
      }) : null;
      return (0, _apidomAst.YamlScalar)({
        content: '',
        position: (0, _apidomAst.Position)({
          start: emptyPoint,
          end: emptyPoint
        }),
        tag,
        anchor,
        styleGroup: _apidomAst.YamlStyleGroup.Flow,
        style: _apidomAst.YamlStyle.Plain
      });
    };
    const createKeyValuePairEmptyValue = node => {
      const emptyPoint = (0, _apidomAst.Point)({
        row: node.endPosition.row,
        column: node.endPosition.column,
        char: node.endIndex
      });
      const {
        valueNode
      } = node;
      const children = (valueNode == null ? void 0 : valueNode.children) || [];
      const tagNode = children.find(isKind('tag'));
      const anchorNode = children.find(isKind('anchor'));
      const tag = typeof tagNode !== 'undefined' ? (0, _apidomAst.YamlTag)({
        explicitName: tagNode.text,
        kind: _apidomAst.YamlNodeKind.Scalar,
        position: toPosition(tagNode)
      }) : (0, _apidomAst.YamlTag)({
        explicitName: '?',
        kind: _apidomAst.YamlNodeKind.Scalar
      });
      const anchor = typeof anchorNode !== 'undefined' ? (0, _apidomAst.YamlAnchor)({
        name: anchorNode.text,
        position: toPosition(anchorNode)
      }) : null;
      return (0, _apidomAst.YamlScalar)({
        content: '',
        position: (0, _apidomAst.Position)({
          start: emptyPoint,
          end: emptyPoint
        }),
        tag,
        anchor,
        styleGroup: _apidomAst.YamlStyleGroup.Flow,
        style: _apidomAst.YamlStyle.Plain
      });
    };

    /**
     * Public API.
     */

    this.enter = function enter(node) {
      // missing anonymous literals from CST transformed into AST literal nodes
      if (node instanceof _TreeCursorSyntaxNode.default && !node.isNamed) {
        const position = toPosition(node);
        const value = node.type || node.text;
        const {
          isMissing
        } = node;
        return (0, _apidomAst.Literal)({
          value,
          position,
          isMissing
        });
      }
      return undefined;
    };
    this.stream = {
      enter(node) {
        const position = toPosition(node);
        return (0, _apidomAst.YamlStream)({
          children: node.children,
          position,
          isMissing: node.isMissing
        });
      },
      leave(stream) {
        return (0, _apidomAst.ParseResult)({
          children: [stream]
        });
      }
    };
    this.yaml_directive = {
      enter(node) {
        var _node$firstNamedChild;
        const position = toPosition(node);
        const version = (node == null || (_node$firstNamedChild = node.firstNamedChild) == null ? void 0 : _node$firstNamedChild.text) || null;
        return (0, _apidomAst.YamlDirective)({
          position,
          name: '%YAML',
          parameters: {
            version
          }
        });
      }
    };
    this.tag_directive = {
      enter(node) {
        const position = toPosition(node);
        const tagHandleNode = node.children[0];
        const tagPrefixNode = node.children[1];
        const tagDirective = (0, _apidomAst.YamlDirective)({
          position,
          name: '%TAG',
          parameters: {
            handle: (tagHandleNode == null ? void 0 : tagHandleNode.text) || null,
            prefix: (tagPrefixNode == null ? void 0 : tagPrefixNode.text) || null
          }
        });
        this.schema.registerTagDirective(tagDirective);
        return tagDirective;
      }
    };
    this.reserved_directive = {
      enter(node) {
        const position = toPosition(node);
        const directiveNameNode = node.children[0];
        const directiveParameter1Node = node.children[1];
        const directiveParameter2Node = node.children[2];
        return (0, _apidomAst.YamlDirective)({
          position,
          name: (directiveNameNode == null ? void 0 : directiveNameNode.text) || null,
          parameters: {
            handle: (directiveParameter1Node == null ? void 0 : directiveParameter1Node.text) || null,
            prefix: (directiveParameter2Node == null ? void 0 : directiveParameter2Node.text) || null
          }
        });
      }
    };
    this.document = {
      enter(node) {
        const position = toPosition(node);
        return (0, _apidomAst.YamlDocument)({
          children: node.children,
          position,
          isMissing: node.isMissing
        });
      },
      leave(node) {
        node.children = node.children.flat();
      }
    };
    this.block_node = {
      enter(node) {
        return node.children;
      }
    };
    this.flow_node = {
      enter(node) {
        const [kindCandidate] = node.children.slice(-1);

        // kind node is present in flow node
        if (isScalar(kindCandidate) || isMapping(kindCandidate) || isSequence(kindCandidate)) {
          return node.children;
        }

        // kind node not present in flow node, creating empty node
        const emptyPoint = (0, _apidomAst.Point)({
          row: kindCandidate.endPosition.row,
          column: kindCandidate.endPosition.column,
          char: kindCandidate.endIndex
        });
        const emptyScalarNode = (0, _apidomAst.YamlScalar)({
          content: '',
          anchor: kindNodeToYamlAnchor(kindCandidate),
          tag: kindNodeToYamlTag(kindCandidate),
          position: (0, _apidomAst.Position)({
            start: emptyPoint,
            end: emptyPoint
          }),
          styleGroup: _apidomAst.YamlStyleGroup.Flow,
          style: _apidomAst.YamlStyle.Plain
        });
        return [...node.children, emptyScalarNode];
      }
    };
    this.tag = {
      enter() {
        return null;
      }
    };
    this.anchor = {
      enter() {
        return null;
      }
    };
    this.block_mapping = {
      enter(node) {
        const position = toPosition(node);
        const tag = kindNodeToYamlTag(node);
        const anchor = kindNodeToYamlAnchor(node);
        const mappingNode = (0, _apidomAst.YamlMapping)({
          children: node.children,
          position,
          anchor,
          tag,
          styleGroup: _apidomAst.YamlStyleGroup.Block,
          style: _apidomAst.YamlStyle.NextLine,
          isMissing: node.isMissing
        });
        return this.schema.resolve(mappingNode);
      }
    };
    this.block_mapping_pair = {
      enter(node) {
        const position = toPosition(node);
        const children = [...node.children];
        if (hasKeyValuePairEmptyKey(node)) {
          const keyNode = createKeyValuePairEmptyKey(node);
          children.unshift(keyNode);
        }
        if (hasKeyValuePairEmptyValue(node)) {
          const valueNode = createKeyValuePairEmptyValue(node);
          children.push(valueNode);
        }
        return (0, _apidomAst.YamlKeyValuePair)({
          children,
          position,
          styleGroup: _apidomAst.YamlStyleGroup.Block,
          isMissing: node.isMissing
        });
      }
    };
    this.flow_mapping = {
      enter(node) {
        const position = toPosition(node);
        const tag = kindNodeToYamlTag(node);
        const anchor = kindNodeToYamlAnchor(node);
        const mappingNode = (0, _apidomAst.YamlMapping)({
          children: node.children,
          position,
          anchor,
          tag,
          styleGroup: _apidomAst.YamlStyleGroup.Flow,
          style: _apidomAst.YamlStyle.Explicit,
          isMissing: node.isMissing
        });
        return this.schema.resolve(mappingNode);
      }
    };
    this.flow_pair = {
      enter(node) {
        const position = toPosition(node);
        const children = [...node.children];
        if (hasKeyValuePairEmptyKey(node)) {
          const keyNode = createKeyValuePairEmptyKey(node);
          children.unshift(keyNode);
        }
        if (hasKeyValuePairEmptyValue(node)) {
          const valueNode = createKeyValuePairEmptyValue(node);
          children.push(valueNode);
        }
        return (0, _apidomAst.YamlKeyValuePair)({
          children,
          position,
          styleGroup: _apidomAst.YamlStyleGroup.Flow,
          isMissing: node.isMissing
        });
      }
    };
    this.keyValuePair = {
      leave(node) {
        node.children = node.children.flat();
      }
    };
    this.block_sequence = {
      enter(node) {
        const position = toPosition(node);
        const tag = kindNodeToYamlTag(node);
        const anchor = kindNodeToYamlAnchor(node);
        const sequenceNode = (0, _apidomAst.YamlSequence)({
          children: node.children,
          position,
          anchor,
          tag,
          styleGroup: _apidomAst.YamlStyleGroup.Block,
          style: _apidomAst.YamlStyle.NextLine
        });
        return this.schema.resolve(sequenceNode);
      }
    };
    this.block_sequence_item = {
      enter(node) {
        // flow or block node present; first node is always `-` literal
        if (node.children.length > 1) {
          return node.children;
        }

        // create empty node
        const emptyPoint = (0, _apidomAst.Point)({
          row: node.endPosition.row,
          column: node.endPosition.column,
          char: node.endIndex
        });
        const emptyScalarNode = (0, _apidomAst.YamlScalar)({
          content: '',
          anchor: null,
          tag: (0, _apidomAst.YamlTag)({
            explicitName: '?',
            kind: _apidomAst.YamlNodeKind.Scalar
          }),
          position: (0, _apidomAst.Position)({
            start: emptyPoint,
            end: emptyPoint
          }),
          styleGroup: _apidomAst.YamlStyleGroup.Flow,
          style: _apidomAst.YamlStyle.Plain
        });
        return [emptyScalarNode];
      }
    };
    this.flow_sequence = {
      enter(node) {
        const position = toPosition(node);
        const tag = kindNodeToYamlTag(node);
        const anchor = kindNodeToYamlAnchor(node);
        const sequenceNode = (0, _apidomAst.YamlSequence)({
          children: node.children.flat(),
          position,
          anchor,
          tag,
          styleGroup: _apidomAst.YamlStyleGroup.Flow,
          style: _apidomAst.YamlStyle.Explicit
        });
        return this.schema.resolve(sequenceNode);
      }
    };
    this.sequence = {
      leave(node) {
        node.children = node.children.flat(+Infinity);
      }
    };
    this.plain_scalar = {
      enter(node) {
        const position = toPosition(node);
        const tag = kindNodeToYamlTag(node);
        const anchor = kindNodeToYamlAnchor(node);
        const scalarNode = (0, _apidomAst.YamlScalar)({
          content: node.text,
          anchor,
          tag,
          position,
          styleGroup: _apidomAst.YamlStyleGroup.Flow,
          style: _apidomAst.YamlStyle.Plain
        });
        return this.schema.resolve(scalarNode);
      }
    };
    this.single_quote_scalar = {
      enter(node) {
        const position = toPosition(node);
        const tag = kindNodeToYamlTag(node);
        const anchor = kindNodeToYamlAnchor(node);
        const scalarNode = (0, _apidomAst.YamlScalar)({
          content: node.text,
          anchor,
          tag,
          position,
          styleGroup: _apidomAst.YamlStyleGroup.Flow,
          style: _apidomAst.YamlStyle.SingleQuoted
        });
        return this.schema.resolve(scalarNode);
      }
    };
    this.double_quote_scalar = {
      enter(node) {
        const position = toPosition(node);
        const tag = kindNodeToYamlTag(node);
        const anchor = kindNodeToYamlAnchor(node);
        const scalarNode = (0, _apidomAst.YamlScalar)({
          content: node.text,
          anchor,
          tag,
          position,
          styleGroup: _apidomAst.YamlStyleGroup.Flow,
          style: _apidomAst.YamlStyle.DoubleQuoted
        });
        return this.schema.resolve(scalarNode);
      }
    };
    this.block_scalar = {
      enter(node) {
        const position = toPosition(node);
        const tag = kindNodeToYamlTag(node);
        const anchor = kindNodeToYamlAnchor(node);
        const style = node.text.startsWith('|') ? _apidomAst.YamlStyle.Literal : node.text.startsWith('>') ? _apidomAst.YamlStyle.Folded : null;
        const scalarNode = (0, _apidomAst.YamlScalar)({
          content: node.text,
          anchor,
          tag,
          position,
          styleGroup: _apidomAst.YamlStyleGroup.Block,
          style
        });
        return this.schema.resolve(scalarNode);
      }
    };
    this.comment = {
      enter(node) {
        return (0, _apidomAst.YamlComment)({
          content: node.text
        });
      }
    };
    this.ERROR = function ERROR(node, key, parent, path) {
      const position = toPosition(node);
      const errorNode = (0, _apidomAst.Error)({
        children: node.children,
        position,
        isUnexpected: !node.hasError,
        isMissing: node.isMissing,
        value: node.text
      });
      if (path.length === 0) {
        return (0, _apidomAst.ParseResult)({
          children: [errorNode]
        });
      }
      return errorNode;
    };
  }
});
var _default = exports.default = CstVisitor;