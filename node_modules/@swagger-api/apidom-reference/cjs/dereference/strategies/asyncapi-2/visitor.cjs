"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
exports.__esModule = true;
exports.default = void 0;
var _stampit = _interopRequireDefault(require("stampit"));
var _ramda = require("ramda");
var _apidomCore = require("@swagger-api/apidom-core");
var _apidomError = require("@swagger-api/apidom-error");
var _apidomJsonPointer = require("@swagger-api/apidom-json-pointer");
var _apidomNsAsyncapi = require("@swagger-api/apidom-ns-asyncapi-2");
var _MaximumDereferenceDepthError = _interopRequireDefault(require("../../../errors/MaximumDereferenceDepthError.cjs"));
var _MaximumResolveDepthError = _interopRequireDefault(require("../../../errors/MaximumResolveDepthError.cjs"));
var _util = require("../../util.cjs");
var url = _interopRequireWildcard(require("../../../util/url.cjs"));
var _index = _interopRequireDefault(require("../../../parse/index.cjs"));
var _Reference = _interopRequireDefault(require("../../../Reference.cjs"));
// @ts-ignore
const visitAsync = _apidomCore.visit[Symbol.for('nodejs.util.promisify.custom')];

// initialize element identity manager
const identityManager = (0, _apidomCore.IdentityManager)();

/**
 * Predicate for detecting if element was created by merging referencing
 * element with particular element identity with a referenced element.
 */
const wasReferencedBy = referencingElement => element => element.meta.hasKey('ref-referencing-element-id') && element.meta.get('ref-referencing-element-id').equals((0, _apidomCore.toValue)(identityManager.identify(referencingElement)));
const AsyncApi2DereferenceVisitor = (0, _stampit.default)({
  props: {
    indirections: [],
    namespace: null,
    reference: null,
    options: null,
    ancestors: null
  },
  init({
    indirections = [],
    reference,
    namespace,
    options,
    ancestors = new _util.AncestorLineage()
  }) {
    this.indirections = indirections;
    this.namespace = namespace;
    this.reference = reference;
    this.options = options;
    this.ancestors = new _util.AncestorLineage(...ancestors);
  },
  methods: {
    toBaseURI(uri) {
      return url.resolve(this.reference.uri, url.sanitize(url.stripHash(uri)));
    },
    async toReference(uri) {
      // detect maximum depth of resolution
      if (this.reference.depth >= this.options.resolve.maxDepth) {
        throw new _MaximumResolveDepthError.default(`Maximum resolution depth of ${this.options.resolve.maxDepth} has been exceeded by file "${this.reference.uri}"`);
      }
      const baseURI = this.toBaseURI(uri);
      const {
        refSet
      } = this.reference;

      // we've already processed this Reference in past
      if (refSet.has(baseURI)) {
        return refSet.find((0, _ramda.propEq)(baseURI, 'uri'));
      }
      const parseResult = await (0, _index.default)(url.unsanitize(baseURI), {
        ...this.options,
        parse: {
          ...this.options.parse,
          mediaType: 'text/plain'
        }
      });

      // register new Reference with ReferenceSet
      const reference = (0, _Reference.default)({
        uri: baseURI,
        value: parseResult,
        depth: this.reference.depth + 1
      });
      refSet.add(reference);
      return reference;
    },
    toAncestorLineage(ancestors) {
      /**
       * Compute full ancestors lineage.
       * Ancestors are flatten to unwrap all Element instances.
       */
      const directAncestors = new Set(ancestors.filter(_apidomCore.isElement));
      const ancestorsLineage = new _util.AncestorLineage(...this.ancestors, directAncestors);
      return [ancestorsLineage, directAncestors];
    },
    async ReferenceElement(referencingElement, key, parent, path, ancestors) {
      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);

      // detect possible cycle in traversal and avoid it
      if (ancestorsLineage.includesCycle(referencingElement)) {
        return false;
      }
      const retrievalURI = this.toBaseURI((0, _apidomCore.toValue)(referencingElement.$ref));

      // ignore resolving external Reference Objects
      if (!this.options.resolve.external && url.stripHash(this.reference.uri) !== retrievalURI) {
        // skip traversing this reference element but traverse all it's child elements
        return false;
      }
      const reference = await this.toReference((0, _apidomCore.toValue)(referencingElement.$ref));
      const $refBaseURI = url.resolve(retrievalURI, (0, _apidomCore.toValue)(referencingElement.$ref));
      this.indirections.push(referencingElement);
      const jsonPointer = (0, _apidomJsonPointer.uriToPointer)($refBaseURI);

      // possibly non-semantic fragment
      let referencedElement = (0, _apidomJsonPointer.evaluate)(jsonPointer, reference.value.result);

      // applying semantics to a fragment
      if ((0, _apidomCore.isPrimitiveElement)(referencedElement)) {
        const referencedElementType = (0, _apidomCore.toValue)(referencingElement.meta.get('referenced-element'));
        if ((0, _apidomNsAsyncapi.isReferenceLikeElement)(referencedElement)) {
          // handling indirect references
          referencedElement = _apidomNsAsyncapi.ReferenceElement.refract(referencedElement);
          referencedElement.setMetaProperty('referenced-element', referencedElementType);
        } else {
          // handling direct references
          const ElementClass = this.namespace.getElementClass(referencedElementType);
          referencedElement = ElementClass.refract(referencedElement);
        }
      }

      // detect direct or circular reference
      if (this.indirections.includes(referencedElement)) {
        throw new _apidomError.ApiDOMError('Recursive Reference Object detected');
      }

      // detect maximum depth of dereferencing
      if (this.indirections.length > this.options.dereference.maxDepth) {
        throw new _MaximumDereferenceDepthError.default(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
      }

      // append referencing reference to ancestors lineage
      directAncestors.add(referencingElement);

      // dive deep into the fragment
      const visitor = AsyncApi2DereferenceVisitor({
        reference,
        namespace: this.namespace,
        indirections: [...this.indirections],
        options: this.options,
        ancestors: ancestorsLineage
      });
      referencedElement = await visitAsync(referencedElement, visitor, {
        keyMap: _apidomNsAsyncapi.keyMap,
        nodeTypeGetter: _apidomNsAsyncapi.getNodeType
      });

      // remove referencing reference from ancestors lineage
      directAncestors.delete(referencingElement);
      this.indirections.pop();

      // Boolean JSON Schemas
      if ((0, _apidomNsAsyncapi.isBooleanJsonSchemaElement)(referencedElement)) {
        const booleanJsonSchemaElement = (0, _apidomCore.cloneDeep)(referencedElement);
        // annotate referenced element with info about original referencing element
        booleanJsonSchemaElement.setMetaProperty('ref-fields', {
          $ref: (0, _apidomCore.toValue)(referencingElement.$ref)
        });
        // annotate referenced element with info about origin
        booleanJsonSchemaElement.setMetaProperty('ref-origin', reference.uri);
        // annotate fragment with info about referencing element
        booleanJsonSchemaElement.setMetaProperty('ref-referencing-element-id', (0, _apidomCore.cloneDeep)(identityManager.identify(referencingElement)));
        return booleanJsonSchemaElement;
      }
      const mergeAndAnnotateReferencedElement = refedElement => {
        const copy = (0, _apidomCore.cloneShallow)(refedElement);

        // annotate referenced element with info about original referencing element
        copy.setMetaProperty('ref-fields', {
          $ref: (0, _apidomCore.toValue)(referencingElement.$ref)
        });
        // annotate fragment with info about origin
        copy.setMetaProperty('ref-origin', reference.uri);
        // annotate fragment with info about referencing element
        copy.setMetaProperty('ref-referencing-element-id', (0, _apidomCore.cloneDeep)(identityManager.identify(referencingElement)));
        return copy;
      };

      // attempting to create cycle
      if (ancestorsLineage.includes(referencingElement) || ancestorsLineage.includes(referencedElement)) {
        var _ancestorsLineage$fin;
        const replaceWith = (_ancestorsLineage$fin = ancestorsLineage.findItem(wasReferencedBy(referencingElement))) != null ? _ancestorsLineage$fin : mergeAndAnnotateReferencedElement(referencedElement);
        if ((0, _apidomCore.isMemberElement)(parent)) {
          parent.value = replaceWith; // eslint-disable-line no-param-reassign
        } else if (Array.isArray(parent)) {
          parent[key] = replaceWith; // eslint-disable-line no-param-reassign
        }
        return false;
      }

      // transclude referencing element with merged referenced element
      return mergeAndAnnotateReferencedElement(referencedElement);
    },
    async ChannelItemElement(referencingElement, key, parent, path, ancestors) {
      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);

      // ignore ChannelItemElement without $ref field
      if (!(0, _apidomCore.isStringElement)(referencingElement.$ref)) {
        return undefined;
      }

      // detect possible cycle in traversal and avoid it
      if (ancestorsLineage.includesCycle(referencingElement)) {
        return false;
      }
      const retrievalURI = this.toBaseURI((0, _apidomCore.toValue)(referencingElement.$ref));

      // ignore resolving external Channel Item Objects
      if (!this.options.resolve.external && url.stripHash(this.reference.uri) !== retrievalURI) {
        // skip traversing this channel item but traverse all it's child elements
        return undefined;
      }
      const reference = await this.toReference((0, _apidomCore.toValue)(referencingElement.$ref));
      const $refBaseURI = url.resolve(retrievalURI, (0, _apidomCore.toValue)(referencingElement.$ref));
      this.indirections.push(referencingElement);
      const jsonPointer = (0, _apidomJsonPointer.uriToPointer)($refBaseURI);

      // possibly non-semantic referenced element
      let referencedElement = (0, _apidomJsonPointer.evaluate)(jsonPointer, reference.value.result);

      // applying semantics to a referenced element
      if ((0, _apidomCore.isPrimitiveElement)(referencedElement)) {
        referencedElement = _apidomNsAsyncapi.ChannelItemElement.refract(referencedElement);
      }

      // detect direct or indirect reference
      if (this.indirections.includes(referencedElement)) {
        throw new _apidomError.ApiDOMError('Recursive Channel Item Object reference detected');
      }

      // detect maximum depth of dereferencing
      if (this.indirections.length > this.options.dereference.maxDepth) {
        throw new _MaximumDereferenceDepthError.default(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
      }

      // append referencing channel item to ancestors lineage
      directAncestors.add(referencingElement);

      // dive deep into the referenced element
      const visitor = AsyncApi2DereferenceVisitor({
        reference,
        namespace: this.namespace,
        indirections: [...this.indirections],
        options: this.options,
        ancestors: ancestorsLineage
      });
      referencedElement = await visitAsync(referencedElement, visitor, {
        keyMap: _apidomNsAsyncapi.keyMap,
        nodeTypeGetter: _apidomNsAsyncapi.getNodeType
      });

      // remove referencing channel item from ancestors lineage
      directAncestors.delete(referencingElement);
      this.indirections.pop();
      const mergeAndAnnotateReferencedElement = refedElement => {
        // merge fields from referenced Channel Item with referencing one
        const mergedElement = new _apidomNsAsyncapi.ChannelItemElement([...refedElement.content], (0, _apidomCore.cloneDeep)(refedElement.meta), (0, _apidomCore.cloneDeep)(refedElement.attributes));
        // existing keywords from referencing ChannelItemElement overrides ones from referenced ChannelItemElement
        referencingElement.forEach((value, keyElement, item) => {
          mergedElement.remove((0, _apidomCore.toValue)(keyElement));
          mergedElement.content.push(item);
        });
        mergedElement.remove('$ref');

        // annotate referenced element with info about original referencing element
        mergedElement.setMetaProperty('ref-fields', {
          $ref: (0, _apidomCore.toValue)(referencingElement.$ref)
        });
        // annotate referenced with info about origin
        mergedElement.setMetaProperty('ref-origin', reference.uri);
        // annotate fragment with info about referencing element
        mergedElement.setMetaProperty('ref-referencing-element-id', (0, _apidomCore.cloneDeep)(identityManager.identify(referencingElement)));
        return mergedElement;
      };

      // attempting to create cycle
      if (ancestorsLineage.includes(referencingElement) || ancestorsLineage.includes(referencedElement)) {
        var _ancestorsLineage$fin2;
        const replaceWith = (_ancestorsLineage$fin2 = ancestorsLineage.findItem(wasReferencedBy(referencingElement))) != null ? _ancestorsLineage$fin2 : mergeAndAnnotateReferencedElement(referencedElement);
        if ((0, _apidomCore.isMemberElement)(parent)) {
          parent.value = replaceWith; // eslint-disable-line no-param-reassign
        } else if (Array.isArray(parent)) {
          parent[key] = replaceWith; // eslint-disable-line no-param-reassign
        }
        return false;
      }

      // transclude referencing element with merged referenced element
      return mergeAndAnnotateReferencedElement(referencedElement);
    }
  }
});
var _default = exports.default = AsyncApi2DereferenceVisitor;